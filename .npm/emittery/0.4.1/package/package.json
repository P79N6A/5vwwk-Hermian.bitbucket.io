{"name":"emittery","version":"0.4.1","description":"Simple and modern async event emitter","license":"MIT","repository":{"type":"git","url":"git+https://github.com/sindresorhus/emittery.git"},"author":{"name":"Sindre Sorhus","email":"sindresorhus@gmail.com","url":"sindresorhus.com"},"engines":{"node":">=6"},"scripts":{"build":"babel --out-file=legacy.js index.js","build:watch":"npm run build -- --watch","prepare":"npm run build","test":"xo && tsc --noEmit && nyc ava"},"files":["Emittery.d.ts","index.js","legacy.js","legacy.d.ts"],"typings":"./Emittery.d.ts","keywords":["event","emitter","eventemitter","events","async","emit","on","once","off","listener","subscribe","unsubscribe","pubsub","tiny","addlistener","addeventlistener","dispatch","dispatcher","observer","trigger","await","promise"],"devDependencies":{"@types/node":"^10.1.2","ava":"*","babel-cli":"^6.26.0","babel-core":"^6.26.0","babel-plugin-transform-async-to-generator":"^6.24.1","codecov":"^3.0.0","delay":"^3.0.0","glob":"^7.1.2","nyc":"^12.0.2","ts-node":"^6.0.3","typescript":"^2.9.0","xo":"*"},"nyc":{"reporter":["html","lcov","text"]},"readme":"# <img src=\"media/header.png\" width=\"1000\">\n\n> Simple and modern async event emitter\n\n[![Build Status](https://travis-ci.org/sindresorhus/emittery.svg?branch=master)](https://travis-ci.org/sindresorhus/emittery) [![codecov](https://codecov.io/gh/sindresorhus/emittery/branch/master/graph/badge.svg)](https://codecov.io/gh/sindresorhus/emittery)\n\nIt's only ~200 bytes minified and gzipped. [I'm not fanatic about keeping the size at this level though.](https://github.com/sindresorhus/emittery/pull/5#issuecomment-347479211)\n\nIt's works in Node.js and the browser (using a bundler).\n\nEmitting events asynchronously is important for production code where you want the least amount of synchronous operations.\n\n\n## Install\n\n```\n$ npm install emittery\n```\n\n\n## Usage\n\n```js\nconst Emittery = require('emittery');\nconst emitter = new Emittery();\n\nemitter.on('ðŸ¦„', data => {\n\tconsole.log(data);\n\t// 'ðŸŒˆ'\n});\n\nemitter.emit('ðŸ¦„', 'ðŸŒˆ');\n```\n\n### Node.js 6\n\nThe above only works in Node.js 8 or newer. For older Node.js versions you can use `require('emittery/legacy')`.\n\n\n## API\n\n### emitter = new Emittery()\n\n#### on(eventName, listener)\n\nSubscribe to an event.\n\nReturns an unsubscribe method.\n\nUsing the same listener multiple times for the same event will result in only one method call per emitted event.\n\n##### listener(data)\n\n#### off(eventName, listener)\n\nRemove an event subscription.\n\n##### listener(data)\n\n#### once(eventName)\n\nSubscribe to an event only once. It will be unsubscribed after the first event.\n\nReturns a promise for the event data when `eventName` is emitted.\n\n```js\nemitter.once('ðŸ¦„').then(data => {\n\tconsole.log(data);\n\t//=> 'ðŸŒˆ'\n});\n\nemitter.emit('ðŸ¦„', 'ðŸŒˆ');\n```\n\n#### emit(eventName, [data])\n\nTrigger an event asynchronously, optionally with some data. Listeners are called in the order they were added, but execute concurrently.\n\nReturns a promise for when all the event listeners are done. *Done* meaning executed if synchronous or resolved when an async/promise-returning function. You usually wouldn't want to wait for this, but you could for example catch possible errors. If any of the listeners throw/reject, the returned promise will be rejected with the error, but the other listeners will not be affected.\n\n#### emitSerial(eventName, [data])\n\nSame as above, but it waits for each listener to resolve before triggering the next one. This can be useful if your events depend on each other. Although ideally they should not. Prefer `emit()` whenever possible.\n\nIf any of the listeners throw/reject, the returned promise will be rejected with the error and the remaining listeners will *not* be called.\n\n#### onAny(listener)\n\nSubscribe to be notified about any event.\n\nReturns a method to unsubscribe.\n\n##### listener(eventName, data)\n\n#### offAny(listener)\n\nRemove an `onAny` subscription.\n\n#### clearListeners()\n\nClear all event listeners on the instance.\n\nIf `eventName` is given, only the listeners for that event are cleared.\n\n#### listenerCount([eventName])\n\nThe number of listeners for the `eventName` or all events if not specified.\n\n## TypeScript\n\nDefinition for `emittery` and `emittery/legacy` are included. Use `import Emittery = require('emittery')` or `import Emittery = require('emittery/legacy')` to load the desired implementation.\n\nThe default `Emittery` class does not let you type allowed event names and their associated data. However you can use `Emittery.Typed` with generics:\n\n```ts\nimport Emittery = require('emittery');\n\nconst ee = new Emittery.Typed<{value: string}, 'open' | 'close'>();\n\nee.emit('open');\nee.emit('value', 'foo\\n');\nee.emit('value', 1); // TS compilation error\nee.emit('end'); // TS compilation error\n```\n\n\n## Scheduling details\n\nListeners are not invoked for events emitted *before* the listener was added. Removing a listener will prevent that listener from being invoked, even if events are in the process of being (asynchronously!) emitted. This also applies to `.clearListeners()`, which removes all listeners. Listeners will be called in the order they were added. So-called *any* listeners are called *after* event-specific listeners.\n\nNote that when using `.emitSerial()`, a slow listener will delay invocation of subsequent listeners. It's possible for newer events to overtake older ones.\n\n\n## FAQ\n\n### How is this different than the built-in `EventEmitter` in Node.js?\n\nThere are many things to not like about `EventEmitter`: its huge API surface, synchronous event emitting, magic error event, flawed memory leak detection. Emittery has none of that.\n\n### Isn't `EventEmitter` synchronous for a reason?\n\nMostly backwards compatibility reasons. The Node.js team can't break the whole ecosystem.\n\nIt also allows silly code like this:\n\n```js\nlet unicorn = false;\n\nemitter.on('ðŸ¦„', () => {\n\tunicorn = true;\n});\n\nemitter.emit('ðŸ¦„');\n\nconsole.log(unicorn);\n//=> true\n```\n\nBut I would argue doing that shows a deeper lack of Node.js and async comprehension and is not something we should optimize for. The benefit of async emitting is much greater.\n\n### Can you support multiple arguments for `emit()`?\n\nNo, just use [destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment):\n\n```js\nemitter.on('ðŸ¦„', ([foo, bar]) => {\n\tconsole.log(foo, bar);\n});\n\nemitter.emit('ðŸ¦„', [foo, bar]);\n```\n\n\n## Related\n\n- [p-event](https://github.com/sindresorhus/p-event) - Promisify an event by waiting for it to be emitted\n\n\n## License\n\nMIT Â© [Sindre Sorhus](https://sindresorhus.com)\n","readmeFilename":"readme.md","bugs":{"url":"https://github.com/sindresorhus/emittery/issues"},"homepage":"https://github.com/sindresorhus/emittery#readme","_id":"emittery@0.4.1","_shasum":"abe9d3297389ba424ac87e53d1c701962ce7433d","_resolved":"https://registry.npmjs.org/emittery/-/emittery-0.4.1.tgz","_from":"https://registry.npmjs.org/emittery/-/emittery-0.4.1.tgz"}