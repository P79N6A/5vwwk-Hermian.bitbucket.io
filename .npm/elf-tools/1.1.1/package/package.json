{"name":"elf-tools","version":"1.1.1","description":"Library for parsing and building ELF binary images","main":"index.js","repository":{"type":"git","url":"git+https://github.com/adelphes/elf-tools.git"},"bugs":{"url":"https://github.com/adelphes/elf-tools/issues"},"scripts":{"test":"mocha"},"devDependencies":{"mocha":"^5.2.0"},"author":{"name":"adelphes"},"license":"MIT","readme":"## elf-tools\n\nA NodeJS library for building and parsing ELF (Executable and Linker Format) binaries.\n\n### Building an ELF image\n\nThere are two ways to output an ELF image:\n\n#### build(opts)\nUse `elf_tools.build(opts)` to create a buffer containing ELF bytes\n```javascript\nconst fs = require('fs');\nconst elf_tools = require('elf-tools');\n\n// create some raw \"Hello world!\" code for the ELF executable\n// note that these instruction bytes are for the Linux OS on Intel/AMD x64 platform\nconst code = Buffer.from(\n '488d3523000000'    // lea    rsi,[rip+0x23]\n+'48c7c20d000000'    // mov    rdx,0xd\n+'48c7c701000000'    // mov    rdi,0x1\n+'48c7c001000000'    // mov    rax,0x1\n+'0f05'              // syscall\n+'4831ff'            // xor    rdi,rdi\n+'48c7c03c000000'    // mov    rax,0x3c\n+'0f05'              // syscall\n+'48656c6c6f20776f726c64210a'\t// \"Hello world!\\n\"\n, 'hex');\n\n// build the ELF executable with the code\nconst image = elf_tools.build({\n    code,\n});\n\n// save the ELF image as a binary executable file\nfs.writeFileSync('./a.out', image, { mode: 0o755 });\n\n```\n\n#### createBuildStream(opts)\nUse `elf_tools.createBuildStream(opts)` and pipe the result to another [Writable](https://nodejs.org/api/stream.html#stream_writable_streams) stream\n```javascript\nconst fs = require('fs');\nconst elf_tools = require('elf-tools');\n\n// create some raw \"Hello world!\" code for the ELF executable\n// note that these instruction bytes are for the Linux OS on Intel/AMD x64 platform\nconst code = Buffer.from(\n '488d3523000000'    // lea    rsi,[rip+0x23]\n+'48c7c20d000000'    // mov    rdx,0xd\n+'48c7c701000000'    // mov    rdi,0x1\n+'48c7c001000000'    // mov    rax,0x1\n+'0f05'              // syscall\n+'4831ff'            // xor    rdi,rdi\n+'48c7c03c000000'    // mov    rax,0x3c\n+'0f05'              // syscall\n+'48656c6c6f20776f726c64210a'\t// \"Hello world!\\n\"\n, 'hex');\n\n// create a ELF stream to output the ELF image bytes\nconst elf_stream = elf_tools.createBuildStream({\n    code,\n});\n\n// create a writable file stream\nconst file_stream = fs.createWriteStream('./a.out', { mode: 0o755 });\n\n// pipe the ELF bytes to the file\nelf_stream.pipe(file_stream);\n\n```\nOnce the file is saved, run it from a terminal:\n```\n$ ./a.out\nHello world!\n```\n\n### Parsing ELF files\n\nTo parse an ELF file:\n```javascript\nconst fs = require('fs');\nconst elf_tools = require('elf-tools');\n\n// read the file into a buffer\nconst elf_bytes = fs.readFileSync('./a.out');\n\n// parse the data\nconst elf = elf_tools.parse(elf_bytes);\n\n// elf is an object containing the parsed ELF-header, program headers (if any) and sections\n\n```\n\n### Documentation\n\n### `build(opts)`\n\nBuild an ELF image\n- **opts**: Object containing code and data to place inside the ELF image\n  - **code**: *Buffer*. Raw executable code bytes. The ELF builder places this data in a *.text* section. All calls to `build()` must include a code buffer. The caller must ensure the code bytes represent valid instructions for the target machine. **Important**: the code must be position-independant with no relocations.\n  - **rodata**: *Buffer* (optional). Raw read-only data bytes. The ELF builder places any read-only data in the *.text* section immediately following the code buffer. If this data needs aligning to a particular byte boundary, the code buffer should be padded accordingly.\n  - **rwdata**: *Buffer* (optional). Raw read/write data bytes. The ELF builder places any writable data in a *.data* section following the code and read-only data\n  - **bss_length**: *integer* (optional). Length of uninitialised (writable) data bytes. The ELF builder locates this data after the rwdata buffer. Although the data is \"uninitialized\" (because it takes up no space in the ELF image), when the image is run, this section is always zero-filled.\n  - **base_address**: *integer* (optional). Memory address for loading the elf image (default: 0x400000)\n  - **entry_offset**: *integer* (optional). Byte offset into the code buffer for the first instruction (default: 0)\n  - **elf_header**: *Object* (optional). Custom ELF header values. See the notes below for the list of fields supported in this object.\n  \n- returns **Buffer** containing the complete ELF image\n\n#### Customising the ELF header\n\nBy default, the constructed ELF header contains values based upon your current executing platform. You can override some of these values by passing an **elf_header** object to `build()`. The customisable values include:\n\n- **elfsig**: *string* ELF signature\n- **class**: *string* `'32'` or `'64'` (note that this value is passed as a string, not an integer)\n- **endian**: *string* `'lsb'` or `'msb'`\n- **osabi**: *string* Any of the allowed values in `lib/constants.js`\n- **abiversion**: *string* Any of the allowed values in `lib/constants.js`\n- **type**: *string* Any of the allowed values in `lib/constants.js`\n- **machine**: *string* Any of the allowed values in `lib/constants.js`\n- **version**: *integer* Any of the allowed values in `lib/constants.js`\n- **entry**: *integer* ELF entrypoint. *Note*: this value cannot be set if either `base_address` or `entry_offset` are set.\n- **flags**: *integer*\n\nThe default values for these fields can be found in `lib/elf_header.js`. Any customised values passed to `build()` are **not validated** - make sure you set correct values or the resulting ELF image is likely to be invalid.\n\n#### Example\n\nThis example uses all 4 fields (code, r/o data, r/w data, bss data) to build an executable which:\n- writes out a prompt (r/o data)\n- then reads user-inputted text into a buffer (r/w data)\n- then reverses the text using scratch space (bss data)\n- finally writes out the reversed text and exits the program\n\n```javascript\nconst fs = require('fs');\nconst elf_tools = require('elf-tools');\n\nconst opts = {\n    // note that these instruction bytes are for the Linux OS on Intel/AMD x64 platform\n    // you can find the source to this program at https://github.com/adelphes/elf-tools/blob/master/test/programs/reverse/reverse.s\n    code: Buffer.from(`\n488d3579 00000048 c7c21c00 0000e85c 00000048 8d358600 000048c7 c2000100\n00e83e00 000048ff c84889c2 488d3d6d 01000048 01c78a0e 880f48ff cf48ffc6\n4883e801 75f04889 fe48ffc6 c604160a 48ffc2e8 17000000 4831ff48 c7c03c00\n00000f05 bf010000 004831c0 0f05c348 c7c70100 000048c7 c0010000 000f05c3\n    `.replace(/\\s+/g,''), 'hex'),\n    \n    // add the prompt as read-only bytes - the extra null bytes pad the section to an 8-byte alignment.\n    rodata: Buffer.from('Enter some text to reverse: \\0\\0\\0\\0', 'ascii'),\n\n    // pre-allocate 256 zero bytes in the program to store the user-input\n    rwdata: Buffer.alloc(256),\n\n    // reserve another 256 bytes of memory for us to reverse the text\n    bss_length: 256,\n}\n\n// create a ELF stream to output the ELF image bytes\nconst elf_stream = elf_tools.createStream(opts);\n\n// create a writable file stream\nconst file_stream = fs.createWriteStream('./reverse', { mode: 0o755 });\n\n// pipe the ELF bytes to the file\nelf_stream.pipe(file_stream);\n\n```\nOnce the file is saved, run it\n```\n$ ./reverse\nEnter some text to reverse: abcdef\nfedcba\n```\n","readmeFilename":"README.md","homepage":"https://github.com/adelphes/elf-tools#readme","_id":"elf-tools@1.1.1","_shasum":"b71bbdd37a9474bde2ad7a86057982da7b166582","_resolved":"https://registry.npmjs.org/elf-tools/-/elf-tools-1.1.1.tgz","_from":"https://registry.npmjs.org/elf-tools/-/elf-tools-1.1.1.tgz"}